### basics
- node_modules에는 npm으로 설치한 모든 패키지가 저장된다.
- dependencies는 프로젝트가 작동되려면 필요한 패키지들이다.
- npm i express를 명령할때 express가 의존하고 있는 dependencies들도 같이 설치가 된다. 
- npm은 package.json을 보고 dependencies를 찾아서 그 안에 있는 모듈을 설치한다. 
- package-lock.json은 패키지들을 안전하게 관리해준다. 
- node_modules는 파일이 크기때문에 .gitignore에 넣어준다.
- package.json은 텍스트 파일이기 때문에 내용을 수정하고 저장해도 문제가 되지 않는다. 이미 모든게 node_modules폴더에 설치되어있다. 
- devDependencies는 개발자에게 필요한 dependencies이다.
- dependencies는 프로젝트가 필요한 패키지이고 devDependencies는 개발자에게 필요한 패키지다. 
- 자동차에 비유한다면 자동차의 연료는 dependencies이고 차에서 음악을 들을수 있게 하는건 devDependencies이다. 

### Babel 
- 바벨은 자바스크립트 컴파일러이다.
- nodeJS가 이해하지 못하는 최신 자바스크립트 코드가 있다. 
- 바벨은 우리가 작성한 최신 자바스크립트를 컴파일해준다. 
- nodeJS를 위한 바벨 사용하기(npm i --save-dev @babel/core)
- npm install @babel/preset-env @babel/node --save-dev 
- preset은 바벨의 플러그인이다. 
- babel-node가 최신 자바스크립트 문법 코드로 index.js를 실행시켜준다.
- babel-node를 사용하기 위해 babel.config.json파일을 생성해서 babel에 추가하고 싶은 플러그인을 넣는다. 

### Express
- 서버는 24시간 내내 온라인에 연결된 컴퓨터라고 할수있다. (request를 listening하고 있다.)
- callback은 서버가 시작될때 작동하는 함수다. 
- port는 컴퓨터의 문과 같다. 
- GET은 HTTP method이다. 
- HTTP는 서버가 소통하는 방법이다. 
- GET은 "저 페이지를 갖다줘" 라는 의미이다. 
- GET Request를 Response할 서버가 필요하다. 
- express에서 route handler에는 addEventListener처럼 event는 없지만 request, response object가 있다.
- resquest를 받으면 response를 return해야한다. res.end() / res.send("I still love you.")

### middleware
- middleware는 중간(middle)에 있는 software다. 
- 결국 모든것이 middleware이다. 
- middleware는 request와 response의 사이에 있다. 
- 모든 controller(handler)는 middleware이고 모든 middleware는 controller(handler)이다. 
- next argument는 다음 함수를 호출해준다. 
- app.get에서 get은 path를 필요로한다. path는 URL이고 handler에는 다수의 handler를 사용할수 있다. 
- app.get의 2번째 인자에는 함수가 들어가야한다.
- handler는 middleware가 될수 있다. 
- middleware는 작업을 다음 함수에게 넘기는 함수이다. 
- app.use()는 global middleware를 만들수 있게 해준다. (순서가 매우 중요!)
- app.use()에 middleware를 두면 모든 route에 적용된다. 
- middleware가 next() 호출하지 않으면 다음 함수들은 실행되지 않는다. 
- 관습적으로 응답을 해주는 마지막 controller에는 next를 쓰지 않는다. 
- middleware를 global하게 쓰려면 맨위에 있어야한다. 
- npm i morgan (HTTP logger)
- morgan함수는 middleware를 리턴해준다. 

### Router
- Router는 컨트롤러와 URL의 관리를 쉽게해준다. 
- 모든 파일은 모듈이고, 거품과도 같다. 
- import하기 위해서는 먼저 export를 해야한다. 
- 하나의 파일 안에 있는 모든건 다른 파일로 부터 완전히 private 상태이다. 
- default export를 하면 import를 할때 원하는 이름으로 바꿀수있다. 
- 파일은 한가지 default export 밖에 가질수없다.  
- /:id는 pathparameter이다. 
- /upload가 /:id보다 위에 있어야 하는이유는 :id자리에 upload가 오면 id로 인식한다.  
- 정규식은 문자열로부터 특정정보를 추출하내는 방법이다. 

### PUG
- Pug는 템플릿 엔진이다. 
- npm i pug
- 뷰엔진 셋팅 app.set("view engine", "pug");
- views 폴더 생성
- pug가 파일을 렌더링해서 평범한 html로 변환해준다. 
- cwd(current working directory)는 package.json에서 node.js를 실행하고 있는 장소가 된다. 
- 뷰엔진은 process.cwd() + "/views"에서 작동한다. 
- app.set("views", process.cwd() + "/src/views");
- pug파일안에 자바스크립트 코드를 넣을수 있다. #{}
- pug는 watch.pug에 있는 코드를 받아서 모든걸 체크하고 자바스크립트를 실행한다. 그리고 그것을 유저에게 제공한다. 이것을 렌더링이라고 함. 
- partials폴더를 만들어서 반복되는 html 문서를 include할수있다. 
- extends를 통해 pug파일을 상속할수 있다. 
- block을 통해서 필요한 부분에 내용을 넣을수 있다. 
- block은 확장한 템플릿 안에 내용을 넣을 수 있는 창문 또는 문과 같다. 
- res.render()에서 1번째 인자는 받을 파일 이름이고 2번째인자는 pug파일에서 받는 변수이다. 
- 조금더 이쁜 CSS를 위해 MVP CSS 임포트하기 (임시방편)
- <link rel="stylesheet" href="https://unpkg.com/mvp.css">
- h1=pageTitle은 h1 #{pageTitle}과 같다. 
- h1태그에 하나의 variable 값만 넣는 경우라면 h1=pageTitle로 하면 된다. 
- mixin은 데이터를 받을수 있는 partial을 말한다. 
- #{} 방식은 attribute(href,class,id)에는 적용할수없다. (백틱사용하기 자바스크립트 template literal)
- href의 앞머리 부분에 /를 넣으면 어디에 있든 상관없이 root경로 + /으로 가게 되어있다. (absolute url)
- 그러나 /를 지우면 relative url이 된다. 

### Parameter
- GET 방식은 구글이나 네이버에서 뭔가를 검색할때 그 검색어가 주소창에 포함되어 있다. 
- POST 방식은 파일을 보내거나, database에 있는 값을 바꾸는 뭔가를 보낼때 사용한다. 
- res.redicrect()는 브라우저가 redicrect(자동으로 이동)하도록 한다. 
- express.urlencoded()을 사용하면 form의 body를 이해할수있다. 
- express.urlencoded()의 옵션중 extended는 body에 있는 정보들을 보기 좋게 형식을 갖춰주는 일을 한다. 
- server.js에서 routes를 사용하기 전에 express.urlencoded() middleware를 사용해야한다. 
- express application이 form의 value들을 이해할수 있도록 하고 우리가 쓸수 있는 멋진 자바스크립트 형식으로 변형시켜준다. 
- req.body는 form에 있는 value의 javascript representation이다.    
- input태그에서 name을 명시해줘야 req.body를 받을수있다. 
- controller 생성 -> router 생성(해당 컨트롤러 사용) 

### Database(mongoDB, mongoose)
- mongoDB는 document-based(문서기반)이다. 
- 일반적인 데이터베이스는 sql-based이다.(엑셀같은 행기반)
- mongoDB에서 저장하는 것들은 JSON-like-document이다. 
- mongoDB macOS 설치방법
```bash
install mongoDB Community Edition
xcode-select --install
brew tap mongodb/brew
brew install mongodb-commnunity@4.4
brew services start mongodb-commnunity@4.4
```
- mongoose는 node.js와 mongoDB를 이어주는 다리가 된다. 
- mongoDB가 잘설치되었는지 확인하기 위해 터미널에서 mongo입력후 show dbs
- npm i mongoose
- server.js에 db.js를 import를 하면 mongoDB와 연결을 할수있다. 
- database가 알아야 할것은 데이터가 어떻게 생겼는가이다. 
- model을 생성하기 전에 먼저 model의 형태(schema)를 정의해줘야한다. 
- db를 mongoose와 연결시켜서 video model을 인식시킨다. 
- init.js는 모든걸 초기화시켜준다. 
- server.js는 express 된것과 server의 configuration에 관련된 코드만 처리하기 위해 만들어졌다. 
- database나 models 같은 것들은 init.js에 넣는다. 
- callback이란 무언가가 발생하고 난 다음 호출되는 function이다. 
- app.listen(PORT, handleListening)에서 handleListening이 콜백함수이다. 
- 콜백은 특별한것이 아니라 javascript에서 기다림을 표현하는 하나의 방법이다.    
- 콜백함수에서 실행되는 코드는 그 아래쪽에 있는 코드를 실행하고 마지막에 실행된다. 
- 콜백함수의 실행순서를 정하기 위해서는 콜백함수안에 다시 콜백함수를 넣어야한다. 
- Promise는 callback의 최신버전이라고 생각하면된다. 
- await을 Video.find()앞에 적으면 find는 우리가 callback을 필요로 하지 않는다는걸 알게된다. 그렇기에 find는 찾아낸 비디오를 바로 출력해준다.  
- 에러를 출력하기 위해서는 try/catch문을 사용한다. 
- async/await이 대단한 이유는 await가 database를 기다려주기 때문이다. 
- javascript는 원래 기다리는 기능이 없었다. 
- 코딩 규칙상 await는 function안에서만 사용이 가능한데 해당 function이 async일때만 가능하다. 
- 에러는 catch문에 넣어준다. 
- javascript에서 무엇을 return하는것이 중요한게 아니라 어떤 function을 호출하는지가 더 중요하다. 
- 우리가 return을 쓰는이유는 function이 render작업후 종료되도록 하기위해서다. 그렇기 때문에 return자체는 필수요소가 아니다. 
- return이 아니라 실행되는 function들에 집중해야한다. 
- mongoose가 스키마에서 설정한 type을 통해 String으로 되어있다면 Number를 String으로 변환해준다. 
- 이것이 데이터의 형태를 미리 정해뒀을 때 얻는 장점중 하나이다. 
- video.save()에서 save는 promise를 return 해주는데 이 말은 save 작업이 끝날때까지 기다려줘야한다. 
- save는 promise를 return하고 이걸 await하면 document가 return 된다. 
- collections는 document들의 묶음이다. 
- minlength와 maxlength는 HTML input 태그에서도 할수 있지만 해커들이 HTML 요소를 삭제해서 접근을 할수 있기 때문에 database에서 validation을 해야 보호 받을수 있다. 
- 에러체크를 먼저하면 나머지 코드는 에러를 걱정할필요가 없게된다. 
- mongoose 미들웨어를 만들때 무조건 model이 생성되기 전에 만들어야한다. 
- mongoose의 static메소드를 통해서 Video 모델에 직접 접근해서 직접 function을 생성할수 있다. 
- 위의 방식대로 다른 function을 어디서 import 할 필요가 없고 Video만 import 하면 formatHashtags도 딸려온다. 

### User Authentication
- 해싱은 일방향 함수인데 문자열이 필요하다. (출력값으로 입력값을 알아낼수 없다 / 같은 입력값으로 항상 같은 출력값이 나온다)
- DB에 password를 저장하지않고 해싱된 password를 저장한다. 
- npm i bcrypt
- bcrypt가 rainbow table공격을 막아준다. 
- saltRounds는 해시된값을 다시 그 수만큼 해시하는것이다. 
- $or operator를 쓰면 각 조건이 true일 때 실행되게 만들수 있다. 
- res.render()로 보내면 기본 상태코드는 200이된다. 

### Sessions and Cookies
- 유저를 기억하는 방법 중 한가지는 유저에게 쿠키를 보내주는것이다. 
- 쿠키를 이해하기 위해서는 우선 세션에 대해 알아야한다. 
- 쿠키는 백엔드와 프런트간의 정보교환을 하는것이고 session ID로 유저를 인식할수 있다.
- 쿠키는 sessionID를 전송하는데 사용이 된다. sessionID가 쿠키안에 저장되고 백엔드에도 저장된다. 
- 세션은 백엔드와 브라우저간에 어떤 활동을 했는지 기억하는걸 말한다. 
- 세션은 브라우저와 백엔드 사이의 memory, history 같은거다. 
- 이것이 작동하려면 백엔드와 브라우저가 서로에 대한 정보를 가지고 있어야한다. 
- HTTP는 요청을 받고 처리를 끝내면 서버에서는 누가 요청을 보냈는지 잊어버리게 된다. (stateless 무상태)
- 한번 연결이 되었다가 끝난다. 이 둘사이 연결에 state가 없는것
- npm i express-session
- express-session 미들웨어가 사이트로 들어오는 모두를 기억하게 된다. 
- express-session 미들웨어가 브라우저에 cookie를 전송한다. 
- cookie는 백엔드가 브라우저에 주는 정보이다. 쿠키에는 정해진 규칙이 있기 때문에, 매번 백엔드에 요청할때 브라우저는 알아서 그 요청에 쿠키를 덧붙이게된다.   
- 브라우저는 우리가 매번 백엔드 localhost에 있는 URL로 요청을 보낼때마다 쿠키가 요청과 같이 전송이 된다. 
- 사이트를 새로고침할때마다(백엔드에 요청을 보낼때마다) [개발자도구]-[어플리케이션]-[쿠키]에서 텍스트(쿠키)가 백엔드로 같이 보내진다. 
- express가 세션을 메모리에 저장하고 있기 때문에 서버를 재시동하면 세션이 사라진다.     
- 백엔드의 각 세션들은 id를 가지고 있고 이 id를 브라우저에게 보낸다. 
- 서로 다른 브라우저에서는 다른 쿠키를 가지고 있고 다른 세션 id를 가지고 있다. 
- 세션과 세션id는 브라우저를 기억하는 방식중 하나이다. 백엔드에 요청을 보낼때마다 이 id를 같이 보내줘야한다. 그러면 백엔드가 기억할수 있다.
- 세션 id를 가지고 있으면 세션 object에 정보를 추가할수 있다. 
- 브라우저에서 웹사이트를 방문할때마다 세션 미들웨어가 있으면 express가 알아서 그 브라우저를 위한 세션 id를 만들고 브라우저에게 보내준다. 
- 그러면 브라우저가 쿠키에 그 세션id를 저장하고 express에서도 그 세션을 세션 DB에 저장한다. 세션 DB에 있는 id와 쿠키에 있는 id가 같도록 하기위해서.
- 그러면 브라우저한테 보내서 쿠키에 저장한 세션 id를 브라우저가 localhost:4000의 모든 url에 요청을 보낼때마다 세션 id를 요청과 함께 보낸다. 
- 그러면 백엔드에서 어떤 유저가, 어떤 브라우저에서 요청을 보냈는지 알수있게된다. 
- 브라우저한테 우리 백엔드 url을 방문할 때마다 보여줘야하는 id카드를 주는거다. 
- 쿠키가 이런 일처리를 해주기 때문에 좋다. 
- 유저한테 쿠키를 주면 유저가 웹사이트를 방문할때마다 알아서 그 쿠키를 보내주기 때문에. 
- 모든 pug 파일들은 response에 있는 locals object에 접근할수 있다.전역변수이기 때문에. (req.session에는 접근할수없음)
- locals object는 우리가 뭐든 할수 있다. 
- app.use(localsMiddleware)의 위치가 중요하다. app.use(session) 아래에 있어야 작동할수있다. 
- 세션 데이터는 쿠키자체에 저장되지 않고 sessionID만 저장이된다. 세션 데이터는 서버에 저장이된다. 
- npm i connect-mongo  
- 익명의 유저의 세션을 저장할필요는 없다. 
- 모든 유저에게 쿠키를 주지 않고 로그인한 유저에게만 쿠키를 준다. 
- [saveUninitialized]는 세션을 수정할 때만 세션을 DB에 저장하고 쿠키를 넘겨준다. 
- IOS나 안드로이드 앱을 만들때 쿠키를 갖지 않기때문에 token을 사용한다.
- 브라우저에서 인증을 할때는 쿠키를 이용해서 세션 인증을 할수있다. 
- [secret]은 쿠키에 sign할때 사용하는 string이다. 
- 쿠키에 sign하는 이유는 백엔드가 쿠키를 줬다는걸 보여주기 위함이다. 
- [개발자도구]-[어플리케이션]-[쿠키]에서 [Domain]은 쿠키를 만든 백엔드가 누구인지 알려준다. 
- [Expires]에서 쿠키의 만료날짜가 명시되어 있지 않으면 브라우저를 닫거나 컴퓨터를 재시작하면 세션은 사리지게 된다. 
- 1. .env파일을 만든다. 2. env파일을 .gitignore에 추가한다. 3. 비밀로 해야하는 string을 process.env.(환경변수)로 바꾼다.
- npm i dotenv
- dotenv 패키지는 env파일을 읽고 각각의 변수들을 process.env에 넣는다. 
- dotenv를 가장먼저 실행해야 다른 파일에서도 process.env를 받아들일수 있다. 
- require를 사용하면 모든파일에 require을 적용해야한다. (import "dotenv/config";를 사용하면 첫시작의 파일에서만 import하면 된다)

### OAuth(Github)
- 깃헙을 통해 로그인 기능을 사용하고 싶다면 먼저 유저를 깃헙으로 보낸다. 
- 사용자는 깃헙에서 이메일과 패스워드를 입력한후 우리에게 정보를 공유하는 것을 승인하게된다. 그러면 깃헙은 사용자를 우리 웹사이트로 돌려보낸다. 
- 깃헙은 유저를 token과 함께 redicrect시킨다. 
- Github로그인 - Settings - Developer settings - OAuth Apps - Register a new application
- 1. 사용자를 깃헙으로 보낸다.(https://github.com/login/oauth/authorize?client_id=)
- [allow_signup=false]를 하면 이미 깃헙에 가입이 되어있는 유저만 깃험로그인이 가능하다.
- [scope]는 유저에게서 얼마나 많이 정보를 읽어내고 어떤 정보를 가져올 것에 대한 부분이다. 
- 2. Github에서 받은 코드를 Access 토큰으로 바꾸기
- nodeJS에서는 fetch()를 쓸수 없기 때문에 node-fetch를 설치해야한다. 
- 3. Access토큰으로 user의 정보를 얻을수 있다. 
- Access토큰이 user가 모든걸 할수 있도록 허용하는것은 아니다. scope에 적은 내용에 대해서만 허용해준다. 
- Github 로그인 같은 소셜 로그인을 할때 만일 우리가 email 접근 권한이 있다는게 증명이 된다면 즉, password가 있거나 Github의 이메일이 증명된거라면 그 유저가 email의 주인이라는 뜻이니까 로그인 시켜줄수 있다. 
- 먼저 Github이 주는 이메일 list에서 primary이면서 verified된 email 객체를 찾는다. 그리고 같은 email을 가진 user가 이미 있다면 그 유저를 로그인시켜준다. 

### User Profile
- pug 파일에서 users라는 폴더를 만들고 그 안에서 base를 extends한다면 ../base로 불러와야한다. 